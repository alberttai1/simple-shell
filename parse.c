/************************************************************************  
 *   parse.c  -  The parsing portion of my shell. It will take care of 
 *   multiple commands, arguments, etc. 
 *   
 ************************************************************************/
#include "parse.h"

#define TRUE 1
#define FALSE 0 
#define DELIMITERS " \t\r\n"

/**
 * This is to initalize a parseInfo Structure, 
 * ensuring all the variables are set 
 * @param parseInfo *p: a parseInfo structure to be initalized
 */
void init_info(parseInfo *p) 
{
	int commandCounter = 0; 
	p = malloc(sizeof(parseInfo));
	p->boolInfile = FALSE;
	p->boolOutfile = FALSE;
	p->boolBackground = FALSE; 
	p->pipeNum = 0; 
	for (commandCounter = 0; commandCounter < PIPE_MAX_NUM; commandCounter++)
	{
		p->CommArray[commandCounter].ArgNum = 0; 
	}
}

//  parse a single command 
/**
 * This is to parse a commands and arguments. This will store command 
 * into the command place, and then keep storing arguments until fed 
 * a new command type. 
 * 
 * @param char* command: the string of command/argument that needs to be stored 
 * @param commandType *comm: The command type structure that stores commands 
 * and arguments. 
 */
void parse_command(char * command, struct commandType *comm) 
{
	if (command!=NULL)
	{
		// printf("Command %d\n", comm->ArgNum); 
		if (comm->ArgNum == 0)
		{
			comm->command = malloc(sizeof(command));
			strcpy(comm->command, command); 
			comm->ArgList[0] = malloc(sizeof(command));
			strcpy(comm->ArgList[0], command); 
			comm->ArgNum++; 
		}
		else
		{
			comm->ArgList[comm->ArgNum] = malloc(sizeof(command));
			strcpy(comm->ArgList[comm->ArgNum], command); 	
			comm->ArgNum++;		
		}
		
	}
}

  /*   parse commandline for space separated commands */
/**
 * This parses the command line fed in from the shell, tokenize it and 
 * starts calling the correct places to store it. 
 * 
 * @param char* cmdLine: The command line read in from the shell. It is entire line
 * @return parseInfo: a parse info structure that contains information whether or not
 * there was redirection, piping, and the information that the shell needs to be able
 * to run the commands. 
 */
parseInfo *parse (char *cmdLine) 
{
  	char *command; 
  	int commandCounter = 0; 
  	parseInfo *parsedCommands; 

  	command = strtok(cmdLine, DELIMITERS); 

  	while (command != NULL)
  	{
  		if(strcmp(command, "&") == 0)
  		{
  			parsedCommands->boolBackground = TRUE; 
  		}
  		else if(strcmp(command, "<") == 0)
  		{
  			parsedCommands->boolInfile = TRUE;
  			command = strtok(NULL, DELIMITERS); 
  			strcpy(parsedCommands->inFile, command); 
  		}
  		else if(strcmp(command, ">") == 0)
  		{
  			parsedCommands->boolOutfile = TRUE;
			command = strtok(NULL, DELIMITERS); 
  			strcpy(parsedCommands->outFile, command); 
  		}
  		else if(strcmp(command, "history") == 0)
  		{
  			parse_command(command, &(parsedCommands->CommArray[commandCounter]));
  			command = strtok(NULL, DELIMITERS); 
  			parse_command(command, &(parsedCommands->CommArray[commandCounter]));		
  		}
  		else if(strcmp(command, "|") == 0)
  		{
  			commandCounter = commandCounter + 1; 
  			parsedCommands->pipeNum++;
  			command = strtok(NULL, DELIMITERS);
 			parse_command(command, &(parsedCommands->CommArray[commandCounter]));	 			    			
  		}
  		else
  		{
  			parse_command(command, &(parsedCommands->CommArray[commandCounter]));
  			// commandCounter = commandCounter + 1;
  		}
  		command = strtok(NULL, DELIMITERS); 
  	}
  	return parsedCommands; 
}


/**
 * This prints the information about the parseinfo generated from the parser. 
 * This gives us an idea what the parsed information is about and whether or not
 * the parser is doing it's job properly for the shell. 
 * @param parseInfo *info: The parsed information generated by the parser. 
 */
void print_info (parseInfo *info) {
	int i = 0; 
	for (i = 0; i < info->pipeNum; i++)
	{
		printf("Arg%d: %s\n", i, info->CommArray[i].command);
	}
	printf("inpipe: %s\n", info->boolInfile == TRUE ? "Yes" : "No");
	printf("outpipe: %s\n", info->boolOutfile == TRUE ? "Yes" : "No");
	printf("background: %s\n", info->boolBackground == TRUE ? "Yes" : "No");
	printf("number of pipes %d\n", info->pipeNum); 
	printf("%s ", info->CommArray[0].command);
	if (info->boolInfile)
	{
		printf("< %s ", info->inFile);
	}
	if (info->boolOutfile)
	{
		printf("> %s ", info->outFile);
	}
	printf("\n"); 
}  

/**
 * This just frees the information from the parser after it is done in order
 * to prevent memory leaks. 
 * @param parseInfo: The parsed info that is done being utilized. 
 */
void free_info (parseInfo *info) 
{
	free(info); 
}
